---
title: Gazebo and ROS 2 Communication
description: Understand how to establish seamless communication between Gazebo simulations and ROS 2.
---

import Module2Quiz from '@site/src/components/Quizzes/Module2Quiz';

# Gazebo and ROS 2 Communication

In the previous lessons, we introduced robotic simulation with Gazebo and learned how to integrate various sensors into our simulated robots. Now, it's time to bridge the gap between the simulated world and our robotic software by understanding how Gazebo and ROS 2 communicate. This seamless integration is what makes Gazebo a powerful tool for ROS developers.

## The Role of `ros_gz` Bridge

The `ros_gz` (formerly `ros_ign`) bridge is a crucial package that facilitates communication between ROS 2 and Gazebo (specifically, Gazebo Fortress and later). It provides a set of ROS 2 nodes that translate messages between Gazebo's native topic system and ROS 2 topics. This allows your ROS 2 nodes to publish commands to a simulated robot in Gazebo and subscribe to sensor data coming from the simulation.

The bridge typically handles the conversion of various message types, such as:
*   Joint commands (e.g., `std_msgs/msg/Float64` for position or velocity control)
*   Odometry data (e.g., `nav_msgs/msg/Odometry`)
*   Sensor data (e.g., `sensor_msgs/msg/Image`, `sensor_msgs/msg/LaserScan`, `sensor_msgs/msg/Imu`)
*   Transforms (`tf2_msgs/msg/TFMessage`)

## Reading Sensor Data from Gazebo in ROS 2

When you add a sensor to your robot model in Gazebo using the `libgazebo_ros_sensor` or specific sensor plugins (like `libgazebo_ros_camera.so`, `libgazebo_ros_laser.so`), they automatically publish data to ROS 2 topics.

### Example: Subscribing to a Camera Image Topic

Let's assume you have a camera sensor configured in your robot model that publishes to `/camera/image_raw`. A simple ROS 2 Python node can subscribe to this topic to receive image data:

```python
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image
from cv_bridge import CvBridge
import cv2

class ImageSubscriber(Node):
    def __init__(self):
        super().__init__('image_subscriber')
        self.subscription = self.create_subscription(
            Image,
            '/camera/image_raw',
            self.listener_callback,
            10)
        self.subscription  # prevent unused variable warning
        self.br = CvBridge()
        self.get_logger().info('Image subscriber node started.')

    def listener_callback(self, data):
        self.get_logger().info('Receiving video frame')
        current_frame = self.br.imgmsg_to_cv2(data)
        cv2.imshow("camera", current_frame)
        cv2.waitKey(1)

def main(args=None):
    rclpy.init(args=args)
    image_subscriber = ImageSubscriber()
    rclpy.spin(image_subscriber)
    image_subscriber.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```
This node subscribes to the `/camera/image_raw` topic, converts the ROS `Image` message to an OpenCV image, and displays it.

## Sending Commands to a Simulated Robot from ROS 2

Similarly, you can control your simulated robot by publishing commands to specific ROS 2 topics that Gazebo is listening to. For example, to control the velocity of a robot, you might publish to a `cmd_vel` topic.

### Example: Publishing Velocity Commands

To make a differential drive robot move, you would typically publish `geometry_msgs/msg/Twist` messages to a `/cmd_vel` topic.

```python
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
import time

class VelocityPublisher(Node):
    def __init__(self):
        super().__init__('velocity_publisher')
        self.publisher_ = self.create_publisher(Twist, '/cmd_vel', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0
        self.get_logger().info('Velocity publisher node started.')

    def timer_callback(self):
        msg = Twist()
        msg.linear.x = 0.2  # Move forward at 0.2 m/s
        msg.angular.z = 0.0 # Don't turn
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: Linear X={msg.linear.x}, Angular Z={msg.angular.z}')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    velocity_publisher = VelocityPublisher()
    rclpy.spin(velocity_publisher)
    velocity_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```
This node publishes a `Twist` message every 0.5 seconds, commanding the robot to move forward.

By understanding these communication patterns, you can develop sophisticated control algorithms and perception systems for your simulated robots, paving the way for their deployment in the real world. In the next phase, we will focus on developing practical code examples for these concepts.

---

## Module 2 Quiz

<Module2Quiz />
