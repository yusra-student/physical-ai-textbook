---
title: "ROS 2 Communication: Topics, Services, and Actions"
description: Dive deeper into the core communication mechanisms of ROS 2.
---

import Module1Quiz from '@site/src/components/Quizzes/Module1Quiz';

# ROS 2 Communication: Topics, Services, and Actions

In the previous lessons, we explored the fundamentals of ROS 2 and how to define your robot's structure using URDF. Now, let's delve into the heart of ROS 2: its communication mechanisms. Understanding how ROS 2 nodes communicate is crucial for building complex robotic applications. ROS 2 provides three primary communication patterns: **Topics**, **Services**, and **Actions**.

## Topics: The Asynchronous Data Stream

Topics are the most common communication pattern in ROS 2, used for asynchronous, many-to-many data streaming. When a node publishes data to a topic, any other node subscribed to that topic can receive the data without direct knowledge of the publisher. This decouples the system, allowing for modular and flexible designs.

*   **Publisher**: A node that sends messages to a topic.
*   **Subscriber**: A node that receives messages from a topic.
*   **Message**: The data structure exchanged over a topic. Each topic has a specific message type.

### When to use Topics:

*   Continuous data streams (sensor data, robot joint states, odometry).
*   One-way communication where the sender doesn't expect a direct response.
*   Decoupled systems where multiple nodes might be interested in the same data.

### Example: Publisher and Subscriber (Conceptual)

Imagine a robot's camera publishing image data to a `/camera/image_raw` topic, and an image processing node subscribing to it.

```python
# Minimal Publisher (Conceptual)
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalPublisher(Node):
    def __init__(self):
        super().__init__('minimal_publisher')
        self.publisher_ = self.create_publisher(String, 'topic', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = 'Hello ROS 2: %d' % self.i
        self.publisher_.publish(msg)
        self.get_logger().info('Publishing: "%s"' % msg.data)
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    minimal_publisher = MinimalPublisher()
    rclpy.spin(minimal_publisher)
    minimal_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

```python
# Minimal Subscriber (Conceptual)
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalSubscriber(Node):
    def __init__(self):
        super().__init__('minimal_subscriber')
        self.subscription = self.create_subscription(
            String,
            'topic',
            self.listener_callback,
            10)
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info('I heard: "%s"' % msg.data)

def main(args=None):
    rclpy.init(args=args)
    minimal_subscriber = MinimalSubscriber()
    rclpy.spin(minimal_subscriber)
    minimal_subscriber.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Services: The Synchronous Request/Response

Services are used for synchronous, one-to-one communication where a client sends a request and expects a response from a server. This is ideal for tasks that require a direct result and can block the client until the response is received.

*   **Service Server**: A node that provides a service and waits for requests.
*   **Service Client**: A node that sends a request to a service server and waits for a response.
*   **Service Definition**: Defines the structure of the request and response messages.

### When to use Services:

*   Request/response interactions (e.g., "get current robot pose," "start a specific task").
*   Tasks that require a direct confirmation or result.
*   Operations that are not time-critical or can afford to wait for a response.

### Example: Service Server and Client (Conceptual)

A service could be used to make a robot "add two numbers."

```python
# Service Server (Conceptual)
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts # Custom service definition

class MinimalService(Node):
    def __init__(self):
        super().__init__('minimal_service')
        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)
        self.get_logger().info('Service server ready.')

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info(f'Incoming request: a={request.a}, b={request.b}')
        self.get_logger().info(f'Sending response: sum={response.sum}')
        return response

def main(args=None):
    rclpy.init(args=args)
    minimal_service = MinimalService()
    rclpy.spin(minimal_service)
    minimal_service.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

```python
# Service Client (Conceptual)
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts
import sys

class MinimalClientAsync(Node):
    def __init__(self):
        super().__init__('minimal_client_async')
        self.cli = self.create_client(AddTwoInts, 'add_two_ints')
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Service not available, waiting again...')
        self.req = AddTwoInts.Request()

    def send_request(self, a, b):
        self.req.a = a
        self.req.b = b
        self.future = self.cli.call_async(self.req)
        rclpy.spin_until_future_complete(self, self.future)
        return self.future.result()

def main(args=None):
    rclpy.init(args=args)
    minimal_client = MinimalClientAsync()
    response = minimal_client.send_request(int(sys.argv[1]), int(sys.argv[2]))
    minimal_client.get_logger().info(f'Result of add_two_ints: for {sys.argv[1]} + {sys.argv[2]} = {response.sum}')
    minimal_client.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    if len(sys.argv) != 3:
        print('Usage: ros2 run py_pubsub minimal_client_async A B')
        sys.exit(1)
    main()
```

## Actions: Long-Running Goal-Oriented Tasks

Actions are designed for long-running, goal-oriented tasks that require periodic feedback and can be preempted. They combine aspects of both topics (feedback) and services (request/response for goal/result).

*   **Action Server**: A node that receives goals, provides feedback, and sends a result.
*   **Action Client**: A node that sends a goal, receives continuous feedback, and eventually a final result.
*   **Action Definition**: Defines the structure for the goal, result, and feedback messages.

### When to use Actions:

*   Navigation tasks (e.g., "go to a specific waypoint").
*   Manipulation tasks (e.g., "pick up an object").
*   Any task where continuous monitoring and preemption are required.

### Example: Action Server and Client (Conceptual)

An action could be used for a robot to "count to a specific number."

```python
# Action Server (Conceptual) - Requires custom action definition
# from rcl_interfaces.action import Count
# ... similar to service/topic setup ...
```

```python
# Action Client (Conceptual) - Requires custom action definition
# from rcl_interfaces.action import Count
# ... similar to service/topic setup ...
```

By mastering these three communication patterns, you gain the ability to design and implement robust and sophisticated robotic systems in ROS 2. In the next lessons, we will build upon these foundations to explore more advanced topics and real-world applications.

---

## Module 1 Quiz

<Module1Quiz />
